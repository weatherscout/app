<!DOCTYPE html>
<!-- WeatherScout v1.0.0 -->
<!-- Released on Febuary 24th, 2026 -->
<!-- https://github.com/wxscout -->
<html>
<head>
    <title>WeatherScout</title>
    <link rel="icon" href="https://raw.githubusercontent.com/microsoft/fluentui-emoji/refs/heads/main/assets/Sun%20behind%20small%20cloud/3D/sun_behind_small_cloud_3d.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' rel='stylesheet' />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --glass-bg: rgba(20, 20, 20, 0.85);
            --glass-border-color: rgba(255, 255, 255, 0.1);
            --glass-border: 1px solid var(--glass-border-color);
            --glass-blur: blur(15px);
            --glass-radius: 10px;
            --glass-hover: rgba(255, 255, 255, 0.2);
            --font-family: 'Outfit', sans-serif;
        }
        body, html {
            margin: 0;
            padding: 0;
            font-family: var(--font-family), -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; 
            user-select: none; 
            -webkit-user-select: none; 
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .standard-glass,
        #attribution-bubble,
        #pill-menu-btn, 
        #pill-info-btn,
        .sidebar-panel,
        .settings-popup,
        #full-alert-text-popup,
        .alert-popup,
        .map-popup-base,
        .toast-notification {
            background: var(--glass-bg) !important;
            backdrop-filter: var(--glass-blur) !important;
            -webkit-backdrop-filter: var(--glass-blur) !important;
            border: var(--glass-border); 
            color: white !important;
            border-radius: var(--glass-radius) !important;
            font-family: var(--font-family) !important;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37) !important;
            transition: background 0.2s, border-color 0.2s;
        }
        .sidebar-menu-item:hover, 
        .map-popup-base ul li:hover,
        .settings-item:hover,
        #attribution-bubble:hover,
        #pill-menu-btn:hover,
        #pill-info-btn:hover,
        .sidebar-close-btn:hover,
        .alert-popup:hover {
            background: var(--glass-hover) !important;
            border-color: var(--glass-hover) !important;
            color: white;
            cursor: pointer;
        }
        #pill-menu-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 2000;
            width: 40px;
            height: 40px;
            display: flex;
            padding: 0;
            background: none; 
            border: none;
        }
        #radar-info-pill {
            position: absolute;
            top: 10px;
            left: 60px; 
            z-index: 2000;
            height: 40px;
            display: none; 
            padding: 0;
            width: max-content;
            background: none; 
            border: none;
        }
        #pill-menu-btn {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        #pill-menu-btn .material-symbols-rounded { font-size: 24px; }
        #pill-info-btn {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 0 8px;
            text-align: center;
        }
        #pill-id-time {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 13px;
            line-height: 1.1;
            white-space: nowrap;
        }
        #pill-product {
            font-family: 'Outfit', sans-serif;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.1;
            white-space: nowrap;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        #alert-popup-container {
            position: fixed;
            bottom: 0; left: 0; 
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            align-items: flex-start;
            pointer-events: none; 
            padding-bottom: 10px;
        }
        .alert-popup {
            padding: 15px; 
            margin: 10px 10px 0px 10px;
            width: max-content;
            max-width: 50vw;
            opacity: 0;
            transform: translateX(-120%);
            transition: transform 0.5s ease-out, opacity 0.3s ease-out, background 0.2s, border-color 0.2s;
            cursor: pointer; 
            pointer-events: auto; 
        }
        .alert-popup.fly-in { opacity: 1; transform: translateX(0); }
        .alert-popup.fly-out { opacity: 0; transform: translateX(-120%); }
        .alert-popup h4 { margin: 0 0 8px 0; font-size: 18px; }
        .alert-popup p { margin: 2px 0; font-size: 14px; white-space: normal; }
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: none;
            z-index: 2001;
        }
        #sidebar {
            position: fixed;
            top: 0;
            left: -300px;
            width: 250px;
            height: 100%;
            z-index: 2002;
            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border-radius: 0 10px 10px 0 !important; 
            border-left: none !important;
            border-top: none !important;
            border-bottom: none !important;
        }
        #sidebar.open {
            left: 0;
        }
        .sidebar-header {
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sidebar-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sidebar-close-btn {
            background: none;
            border: 1px solid transparent; 
            color: white;
            cursor: pointer;
            padding: 5px;
            display: flex;
            border-radius: 5px;
            transition: background 0.2s, border-color 0.2s;
        }
        .sidebar-content {
            padding: 10px; 
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 5px; 
        }
        .sidebar-menu-item, .settings-item {
            background: transparent;
            border: 1px solid transparent; 
            color: rgba(255, 255, 255, 0.9);
            width: 100%;
            padding: 12px 15px;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            gap: 15px;
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 400;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .sidebar-item-content {
            display: flex;
            align-items: center;
            gap: 15px;
            text-align: left;
            flex-grow: 1;
        }
        .sidebar-menu-item i, .settings-item i {
            font-size: 22px;
        }
        .dropdown-arrow {
            font-size: 20px;
            transition: transform 0.3s ease;
            margin-left: auto; 
        }
        .sidebar-menu-item.active .dropdown-arrow, .settings-item.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        .sidebar-dropdown-container {
            display: none;
            flex-direction: column;
            padding-left: 15px; 
            gap: 5px;
        }
        .sidebar-dropdown-container.show {
            display: flex;
        }
        .sidebar-submenu-item {
            padding: 10px 15px;
            font-size: 15px;
        }
        .maplibregl-popup-content {
            background: none;
            box-shadow: none;
            padding: 0;
            border-radius: 10px;
        }
        .maplibregl-popup-tip { display: none; }
        .maplibregl-popup-close-button {
            top: 5px;
            right: 5px;
            font-size: 20px;
            z-index: 1;
            color: #ccc;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .map-popup-base { 
            padding: 0; 
            font-size: 14px;
            min-width: 200px; 
            overflow: hidden; 
            touch-action: pan-y; 
        }
        .map-popup-base h4 {
            margin: 0; 
            padding: 12px 10px;
            font-size: 18px;
            text-align: center;
        }
        .map-popup-base .popup-content-area {
            padding: 4px; 
            max-height: 200px; 
            overflow-y: auto; 
            scrollbar-width: thin; 
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        .map-popup-base .popup-content-area::-webkit-scrollbar { width: 4px; }
        .map-popup-base .popup-content-area::-webkit-scrollbar-track { background: transparent; }
        .map-popup-base .popup-content-area::-webkit-scrollbar-thumb { background-color: rgba(255, 255, 255, 0.3); border-radius: 2px; }
        .map-popup-base ul { list-style: none; padding: 0; margin: 0; }
        .map-popup-base ul li {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center; 
            padding: 10px; 
            cursor: pointer;
            user-select: none;
            border-radius: 6px; 
            border: 1px solid transparent; 
            font-size: 14px;
            transition: background 0.2s, border-color 0.2s;
        }
        .map-popup-base ul li button {
            background: none;
            border: none;
            color: inherit; 
            font: inherit; 
            padding: 0;
            margin: 0;
            cursor: pointer;
            width: 100%;
            text-align: center;
            font-size: inherit; 
        }
        .map-popup-base ul li button:focus { outline: none; }
        .map-popup-base .popup-content-area p { margin: 8px 10px; white-space: normal; }
        .map-popup-base .popup-content-area p:first-of-type { margin-top: 10px; }
        .map-popup-base .popup-content-area p:last-of-type { margin-bottom: 10px; }
        .alert-pager {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 30px; 
            border-radius: 0 0 10px 10px;
            padding-bottom: 5px;
        }
        .alert-pager .pager-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3); 
            margin: 0 6px; 
            cursor: pointer;
            transition: all 0.2s ease;
            border: 4px solid transparent; 
            background-clip: padding-box;
            box-sizing: content-box;
        }
        .alert-pager .pager-dot.active {
            background-color: rgba(255, 255, 255, 1); 
            transform: scale(1.2);
        }
        #full-alert-text-popup-overlay, #settings-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: none; 
            z-index: 2000; 
            align-items: center;
            justify-content: center;
        }
        #settings-overlay { z-index: 3000; }
        #full-alert-text-popup, .settings-popup {
            padding: 15px; 
            width: 90%;
            max-width: 400px;
            max-height: 80vh; 
            overflow-y: auto; 
            -ms-overflow-style: none;  
            scrollbar-width: none;  
            position: relative; 
            display: flex;
            flex-direction: column;
        }
        #full-alert-text-popup::-webkit-scrollbar, .settings-popup::-webkit-scrollbar { display: none; }
        #full-alert-text-popup h4, .settings-popup h4 { margin: 0 0 10px 0; font-size: 24px; text-align: center; }
        #full-alert-text-popup p, .settings-popup p { margin: 5px 0; font-size: 16px; line-height: 1.4; }
        #full-alert-text-popup strong { font-weight: bold; }
        #alert-description-container { margin: 0; padding: 0; }
        .settings-category-header {
            font-size: 12px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin: 15px 0 5px 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .settings-splitter {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0 10px 0;
            width: 100%;
        }
        .settings-content-wrapper { display: flex; flex-direction: column; gap: 5px; }
        .toggle-switch-ui {
            width: 36px; 
            height: 20px; 
            background: rgba(255,255,255,0.2);
            border-radius: 10px; 
            position: relative; 
            transition: background 0.3s;
            flex-shrink: 0;
        }
        .toggle-switch-ui::after {
            content: ''; 
            position: absolute; 
            top: 2px; 
            left: 2px;
            width: 16px; 
            height: 16px; 
            background: white; 
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch-ui.active { background: #4CAF50; }
        .toggle-switch-ui.active::after { transform: translateX(16px); }
        #attribution-bubble {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            justify-content: center;
            height: 30px;
            width: 30px;
            border-radius: 15px !important; 
            box-sizing: border-box;
            cursor: pointer;
            overflow: hidden;
        }
        #attribution-bubble.expanded { width: auto; padding: 0 4px; }
        #attribution-bubble .material-symbols-rounded { font-size: 20px; flex-shrink: 0; }
        #attribution-bubble .attribution-text { display: none; margin-left: 4px; margin-right: 4px; font-size: 14px; white-space: nowrap; }
        #attribution-bubble.expanded .attribution-text { display: block; }
        #attribution-bubble .attribution-text a { color: inherit; text-decoration: none; }
        #attribution-bubble .attribution-text a:hover { text-decoration: underline; }
        #toast-container {
            position: fixed;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .toast-notification {
            padding: 8px 16px;
            border-radius: 20px !important;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        .toast-notification.show { opacity: 1; transform: translateY(0); }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="attribution-bubble">
        <i class="material-symbols-rounded">info</i>
        <div class="attribution-text">
            <a href="https://maplibre.org/" target="_blank">MapLibre</a> | <a href="https://carto.com/about-carto/" target="_blank">CARTO</a>, 
            <a href="https://mesonet.agron.iastate.edu/" target="_blank">IEM</a>, 
            <a href="https://noaa.gov/" target="_blank">NOAA</a>,
            <a href="https://weather.gov/" target="_blank">NWS</a>
        </div>
    </div>
    <div id="alert-popup-container"></div>
    <div id="toast-container"></div>
    <div id="pill-menu-container">
        <button id="pill-menu-btn" title="Menu"><i class="material-symbols-rounded">menu</i></button>
    </div>
    <div id="radar-info-pill">
        <button id="pill-info-btn">
            <div id="pill-id-time"></div>
            <div id="pill-product"></div>
        </button>
    </div>
    <div id="sidebar-overlay"></div>
    <div id="sidebar" class="sidebar-panel">
        <div class="sidebar-header">
            <h2>WeatherScout</h2>
            <button id="sidebar-close-btn" class="sidebar-close-btn">
                <i class="material-symbols-rounded">close</i>
            </button>
        </div>
        <div class="sidebar-content">
            <div class="sidebar-menu-group">
                <button class="sidebar-menu-item" onclick="toggleSidebarDropdown('outlooks-dropdown', this)">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">map</i>
                        Outlooks
                    </div>
                    <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                </button>
                <div id="outlooks-dropdown" class="sidebar-dropdown-container">
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day1-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_1</i>Day 1</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day1-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="torn"><i class="material-symbols-rounded">tornado</i>Tornado</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="hail"><i class="material-symbols-rounded">weather_hail</i>Hail</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="1" data-type="wind"><i class="material-symbols-rounded">air</i>Wind</button>
                    </div>
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day2-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_2</i>Day 2</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day2-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="torn"><i class="material-symbols-rounded">tornado</i>Tornado</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="hail"><i class="material-symbols-rounded">weather_hail</i>Hail</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="2" data-type="wind"><i class="material-symbols-rounded">air</i>Wind</button>
                    </div>
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day3-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">counter_3</i>Day 3</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day3-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="3" data-type="cat"><i class="material-symbols-rounded">thunderstorm</i>Categorical</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="3" data-type="prob"><i class="material-symbols-rounded">percent</i>Probabilistic</button>
                    </div>
                    <button class="sidebar-menu-item sidebar-submenu-item" onclick="toggleSidebarDropdown('day48-dropdown', this)">
                        <div class="sidebar-item-content"><i class="material-symbols-rounded">add_circle</i>Day 4-8</div>
                        <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                    </button>
                    <div id="day48-dropdown" class="sidebar-dropdown-container">
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="4" data-type="prob"><i class="material-symbols-rounded">counter_4</i>Day 4 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="5" data-type="prob"><i class="material-symbols-rounded">counter_5</i>Day 5 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="6" data-type="prob"><i class="material-symbols-rounded">counter_6</i>Day 6 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="7" data-type="prob"><i class="material-symbols-rounded">counter_7</i>Day 7 Prob.</button>
                        <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="8" data-type="prob"><i class="material-symbols-rounded">counter_8</i>Day 8 Prob.</button>
                    </div>
                    <button class="sidebar-menu-item sidebar-submenu-item outlook-type" data-day="none" data-type="none">
                        <div class="sidebar-item-content">
                            <i class="material-symbols-rounded">cancel</i>None
                        </div>
                    </button>
                </div>
            </div>
            <button id="sidebar-mosaic-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">radar</i>Mosaic</div>
            </button>
            <button id="sidebar-alerts-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">warning</i>Alerts</div>
            </button>
            <button id="sidebar-sites-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">location_on</i>Sites</div>
            </button>
            <button id="sidebar-settings-btn" class="sidebar-menu-item">
                <div class="sidebar-item-content"><i class="material-symbols-rounded">settings</i>Settings</div>
            </button>
            <input type="file" id="debug-file-input" accept=".json, .geojson" style="display: none;">
        </div>
    </div>
    <div id="settings-overlay">
        <div class="settings-popup">
            <button class="maplibregl-popup-close-button" type="button" aria-label="Close" aria-hidden="true">Ã—</button>
            <h4>Settings</h4>
            <div class="settings-content-wrapper">
                <div class="settings-category-header">Map</div>
                <div class="settings-splitter"></div>
                <button class="settings-item" onclick="toggleSidebarDropdown('site-selection-dropdown', this)">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">my_location</i>
                        Site Selection
                    </div>
                    <i class="material-symbols-rounded dropdown-arrow">expand_more</i>
                </button>
                <div id="site-selection-dropdown" class="sidebar-dropdown-container">
                    <button class="sidebar-menu-item sidebar-submenu-item site-select-option" data-value="Both">
                        <div class="sidebar-item-content">Both</div>
                    </button>
                    <button class="sidebar-menu-item sidebar-submenu-item site-select-option" data-value="WSR-88D">
                        <div class="sidebar-item-content">WSR-88D</div>
                    </button>
                    <button class="sidebar-menu-item sidebar-submenu-item site-select-option" data-value="TDWR">
                        <div class="sidebar-item-content">TDWR</div>
                    </button>
                    <button class="sidebar-menu-item sidebar-submenu-item site-select-option" data-value="None" style="display: none;">
                        <div class="sidebar-item-content">None</div>
                    </button>
                </div>
                <button class="settings-item" id="fly-settings-btn">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">flight_takeoff</i>
                        Fly to Radar
                    </div>
                    <div class="toggle-switch-ui" id="fly-settings-toggle-ui"></div>
                </button>
                <button class="settings-item" id="zone-alerts-settings-btn">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">grid_view</i>
                        Zone Alerts
                    </div>
                    <div class="toggle-switch-ui active" id="zone-alerts-settings-toggle-ui"></div>
                </button>
                <div class="settings-category-header">App</div>
                <div class="settings-splitter"></div>
                <button class="settings-item" id="debug-settings-btn">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">bug_report</i>
                        Debug Mode
                    </div>
                    <div class="toggle-switch-ui" id="debug-settings-toggle-ui"></div>
                </button>
                <button class="settings-item" id="save-settings-btn">
                    <div class="sidebar-item-content">
                        <i class="material-symbols-rounded">save</i>
                        Save Settings
                    </div>
                    <div class="toggle-switch-ui" id="save-settings-toggle-ui"></div>
                </button>
            </div>
        </div>
    </div>
    <div style="display: none;">
        <input type="checkbox" id="radar-toggle" checked>
        <input type="checkbox" id="radar-sites-toggle" checked>
    </div>
    <script>
        let debugModeEnabled = false;
        const appStartTime = performance.now();
        const getTs = () => `[${((performance.now() - appStartTime) / 1000).toFixed(3)}s]`;
        
        const Logger = {
            info: (msg, data = '') => console.log(`${getTs()} [INFO] ${msg}`, data !== '' ? data : ''),
            debug: (func, msg, data = '') => { if (debugModeEnabled) console.debug(`${getTs()} [DEBUG] [${func}] ${msg}`, data !== '' ? data : ''); },
            error: (func, err, data = '') => {
                if (debugModeEnabled) { 
                    console.error(`${getTs()} [ERROR] [${func}]`, err, data !== '' ? data : ''); 
                    console.trace(); 
                } else { 
                    console.error(`${getTs()} [ERROR] [${func}]`, err?.message || err); 
                }
            }
        };

        const alertColorMap = { 'Tornado Warning': '#FF0000', 'Tornado Watch': '#FFFF00', 'Severe Thunderstorm Warning': '#FFA500', 'Severe Thunderstorm Watch': '#DB7093', 'Flash Flood Warning': '#8B0000', 'Flash Flood Statement': '#8B0000', 'Flash Flood Watch': '#2E8B57', 'Flood Warning': '#00FF00', 'Flood Statement': '#00FF00', 'Flood Watch': '#2E8B57', 'Flood Advisory': '#00FF7F', 'Special Marine Warning': '#FFA500', 'Marine Weather Statement': '#FFDAB9', 'Special Weather Statement': '#FFE4B5', 'Storm Warning': '#9400D3', 'Storm Watch': '#FFE4B5', 'Winter Storm Warning': '#FF69B4', 'Winter Storm Watch': '#4682B4', 'Winter Weather Advisory': '#7B68EE', 'Blizzard Warning': '#FF4500', 'Blizzard Watch': '#ADFF2F', 'Ice Storm Warning': '#8B008B', 'Snow Squall Warning': '#C71585', 'High Wind Warning': '#DAA520', 'High Wind Watch': '#B8860B', 'Wind Advisory': '#D2B48C', 'Gale Warning': '#DDA0DD', 'Gale Watch': '#FFC0CB', 'Hurricane Warning': '#DC143C', 'Hurricane Watch': '#FF00FF', 'Tropical Storm Warning': '#B22222', 'Tropical Storm Watch': '#F08080', 'Red Flag Warning': '#FF1493', 'Fire Weather Watch': '#FFDEAD', 'Heat Advisory': '#FF7F50', 'Excessive Heat Warning': '#C71585', 'Excessive Heat Watch': '#800000', 'Freeze Warning': '#483D8B', 'Freeze Watch': '#00FFFF', 'Frost Advisory': '#6495ED', 'Dense Fog Advisory': '#708090', 'Air Quality Alert': '#808080', 'Dust Storm Warning': '#FF8C00', 'Blowing Dust Warning': '#FF8C00', 'Blowing Dust Advisory': '#BDB76B', 'Small Craft Advisory': '#D8BFD8', 'Hazardous Seas Warning': '#D8BFD8', 'Hazardous Seas Watch': '#483D8B', 'Lake Wind Advisory': '#D2B48C', 'Beach Hazards Statement': '#40E0D0', 'Coastal Flood Warning': '#228B22', 'Coastal Flood Watch': '#66CDAA', 'Coastal Flood Advisory': '#7CFC00', 'Tsunami Warning': '#FD6347', 'Tsunami Watch': '#FF00FF', 'Tsunami Advisory': '#D2691E', 'Civil Emergency Message': '#FFB6C1', 'Law Enforcement Warning': '#C0C0C0', 'Shelter In Place Warning': '#FA8072', 'Evacuation - Immediate': '#7FFF00', '911 Telephone Outage': '#C0C0C0', 'Administrative Message': '#FFFFFF', 'Child Abduction Emergency': '#FFFFFF', 'Extreme Wind Warning': '#FF8C00', 'Test': '#F0F8FF' };
        const outlookTypes = { '1': ['cat', 'torn', 'hail', 'wind'], '2': ['cat', 'torn', 'hail', 'wind'], '3': ['cat', 'prob'], '4': ['prob'], '5': ['prob'], '6': ['prob'], '7': ['prob'], '8': ['prob'] }, typeLabels = { 'cat': 'Categorical', 'torn': 'Tornado', 'wind': 'Wind', 'hail': 'Hail', 'prob': 'Prob.' };

        function disableContextMenu(event) {
            Logger.debug('disableContextMenu', 'Triggered', { target: event.target });
            event.stopPropagation();
            event.preventDefault();
        }

        function toggleSidebarDropdown(id, btnElement) {
            Logger.debug('toggleSidebarDropdown', 'Toggling UI Dropdown', { id });
            const dropdown = document.getElementById(id);
            if (dropdown) {
                dropdown.classList.toggle('show');
                btnElement.classList.toggle('active');
            } else {
                Logger.error('toggleSidebarDropdown', new Error('Dropdown element not found'), { id });
            }
        }

        function showToast(message) {
            Logger.debug('showToast', 'Displaying toast', { message });
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.innerText = message;
            container.appendChild(toast);
            requestAnimationFrame(() => { toast.classList.add('show'); });
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => { toast.remove(); }, 300);
            }, 1000);
        }

        const formatNwsText = (text) => {
            Logger.debug('formatNwsText', 'Formatting raw NWS text string', { length: text ? text.length : 0 });
            if (!text) return "";
            return text
                .replace(/\r\n/g, '\n')
                .replace(/\n\n+/g, '@@PARA@@')
                .replace(/\n/g, ' ')
                .replace(/@@PARA@@/g, '<br><br>')
                .trim();
        };

        let radarSiteSelectionMode = 'Both'; 
        let activeSpcDay = 'none';
        let activeSpcType = 'none';
        let activeSiteIdForData = null;
        let activeRadarProductCode = null;
        let flyToRadarSetting = false;
        let zoneAlertsEnabled = true;
        let alertsEnabled = true; 
        let saveSettingsEnabled = false;
        let urlRadarRequest = null;
        const radarSiteDefaultColor = ['case', ['==', ['get', 'statusError'], true], '#8800FF', ['==', ['get', 'isOffline'], true], '#ff0000', ['==', ['get', 'stationType'], 'WSR-88D'], '#0099ff', ['==', ['get', 'stationType'], 'TDWR'], '#ff9900', '#808080'];
        
        document.addEventListener('DOMContentLoaded', () => {
            Logger.info('DOM Content Loaded. Initializing core elements.');
            Logger.debug('DOMContentLoaded', 'Setting up references and bindings.');
            
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const saveSettingsToggleUI = document.getElementById('save-settings-toggle-ui');
            const flySettingsBtn = document.getElementById('fly-settings-btn');
            const flySettingsToggleUI = document.getElementById('fly-settings-toggle-ui');
            const zoneAlertsBtn = document.getElementById('zone-alerts-settings-btn');
            const zoneAlertsToggleUI = document.getElementById('zone-alerts-settings-toggle-ui');
            const debugSettingsBtn = document.getElementById('debug-settings-btn');
            const debugSettingsToggleUI = document.getElementById('debug-settings-toggle-ui');
            const radarToggle = document.getElementById('radar-toggle');
            const sitesToggle = document.getElementById('radar-sites-toggle');
            
            saveSettingsEnabled = localStorage.getItem('saveSettings') === 'true';
            if (saveSettingsEnabled) {
                Logger.debug('DOMContentLoaded', 'Restoring saved settings state.');
                if (localStorage.getItem('debugMode') === 'true') debugModeEnabled = true;
                if (localStorage.getItem('radarVisible') === 'false') radarToggle.checked = false;
                if (localStorage.getItem('sitesVisible') === 'false') sitesToggle.checked = false;
                if (localStorage.getItem('alertsVisible') === 'false') alertsEnabled = false;
                activeSpcDay = localStorage.getItem('activeSpcDay') || 'none';
                activeSpcType = localStorage.getItem('activeSpcType') || 'none';
                activeSiteIdForData = localStorage.getItem('activeSiteId') || null;
                activeRadarProductCode = localStorage.getItem('activeProduct') || null;
                radarSiteSelectionMode = localStorage.getItem('siteSelection') || 'Both';
                flyToRadarSetting = localStorage.getItem('flyToRadar') === 'true';
                if (localStorage.getItem('zoneAlertsVisible') === 'false') zoneAlertsEnabled = false;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const sParam = urlParams.get('s');
            let overrodeSaveSettings = null;

            if (sParam) {
                const flags = sParam.toLowerCase().split(',');
                Logger.info('URL configuration parameters detected', { flags });
                
                flags.forEach(flag => {
                    Logger.debug('parseUrlParams', 'Processing flag', { flag });
                    switch(flag) {
                        case 'ssb': radarSiteSelectionMode = 'Both'; break;
                        case 'ssw': radarSiteSelectionMode = 'WSR-88D'; break;
                        case 'sst': radarSiteSelectionMode = 'TDWR'; break;
                        case 'xss': radarSiteSelectionMode = 'None'; break;
                        case 'ftr': flyToRadarSetting = true; break;
                        case 'xfr': flyToRadarSetting = false; break;
                        case 'zna': zoneAlertsEnabled = true; break;
                        case 'xza': zoneAlertsEnabled = false; break;
                        case 'dbg': debugModeEnabled = true; break;
                        case 'xdb': debugModeEnabled = false; break;
                        case 'sav': overrodeSaveSettings = true; break;
                        case 'xsv': overrodeSaveSettings = false; break;
                        case 'd1c': activeSpcDay = '1'; activeSpcType = 'cat'; break;
                        case 'd1t': activeSpcDay = '1'; activeSpcType = 'torn'; break;
                        case 'd1h': activeSpcDay = '1'; activeSpcType = 'hail'; break;
                        case 'd1w': activeSpcDay = '1'; activeSpcType = 'wind'; break;
                        case 'd2c': activeSpcDay = '2'; activeSpcType = 'cat'; break;
                        case 'd2t': activeSpcDay = '2'; activeSpcType = 'torn'; break;
                        case 'd2h': activeSpcDay = '2'; activeSpcType = 'hail'; break;
                        case 'd2w': activeSpcDay = '2'; activeSpcType = 'wind'; break;
                        case 'd3c': activeSpcDay = '3'; activeSpcType = 'cat'; break;
                        case 'd3p': activeSpcDay = '3'; activeSpcType = 'prob'; break;
                        case 'd4p': activeSpcDay = '4'; activeSpcType = 'prob'; break;
                        case 'd5p': activeSpcDay = '5'; activeSpcType = 'prob'; break;
                        case 'd6p': activeSpcDay = '6'; activeSpcType = 'prob'; break;
                        case 'd7p': activeSpcDay = '7'; activeSpcType = 'prob'; break;
                        case 'd8p': activeSpcDay = '8'; activeSpcType = 'prob'; break;
                        case 'xlk': activeSpcDay = 'none'; activeSpcType = 'none'; break;
                        case 'irm': radarToggle.checked = true; break;
                        case 'xrm': radarToggle.checked = false; break;
                        case 'alt': alertsEnabled = true; break;
                        case 'xal': alertsEnabled = false; break;
                        case 'sit': sitesToggle.checked = true; break;
                        case 'xrs': sitesToggle.checked = false; break;
                        default:
                            if (flag.length === 5 && (flag.startsWith('r') || flag.startsWith('v') || flag.startsWith('l'))) {
                                urlRadarRequest = { id: flag.substring(1), type: flag.charAt(0) };
                            } else {
                                Logger.debug('parseUrlParams', 'Unknown or malformed flag encountered', { flag });
                            }
                            break;
                    }
                });
                
                if (overrodeSaveSettings === true) {
                    saveSettingsEnabled = true;
                    localStorage.setItem('saveSettings', 'true');
                } else if (overrodeSaveSettings === false) {
                    saveSettingsEnabled = false;
                    localStorage.setItem('saveSettings', 'false');
                }
            }

            if (saveSettingsEnabled) saveSettingsToggleUI.classList.add('active'); else saveSettingsToggleUI.classList.remove('active');
            if (debugModeEnabled) debugSettingsToggleUI.classList.add('active'); else debugSettingsToggleUI.classList.remove('active');
            if (flyToRadarSetting) flySettingsToggleUI.classList.add('active'); else flySettingsToggleUI.classList.remove('active');
            if (zoneAlertsEnabled) zoneAlertsToggleUI.classList.add('active'); else zoneAlertsToggleUI.classList.remove('active');
            
            const siteSelectOptions = document.querySelectorAll('.site-select-option');
            siteSelectOptions.forEach(opt => { 
                if (opt.dataset.value === radarSiteSelectionMode) opt.style.background = 'rgba(255, 255, 255, 0.2)'; 
                else opt.style.background = 'transparent';
            });

            function saveCurrentState() {
                Logger.debug('saveCurrentState', 'Evaluating local storage saving', { allowed: localStorage.getItem('saveSettings') === 'true' });
                if (localStorage.getItem('saveSettings') === 'true') {
                    localStorage.setItem('radarVisible', radarToggle.checked);
                    localStorage.setItem('sitesVisible', sitesToggle.checked);
                    localStorage.setItem('alertsVisible', alertsEnabled);
                    localStorage.setItem('activeSpcDay', activeSpcDay);
                    localStorage.setItem('activeSpcType', activeSpcType);
                    localStorage.setItem('activeSiteId', activeSiteIdForData || "");
                    localStorage.setItem('activeProduct', activeRadarProductCode || "");
                    localStorage.setItem('siteSelection', radarSiteSelectionMode);
                    localStorage.setItem('flyToRadar', flyToRadarSetting);
                    localStorage.setItem('zoneAlertsVisible', zoneAlertsEnabled);
                    localStorage.setItem('debugMode', debugModeEnabled);
                    localStorage.setItem('lastZoom', map.getZoom());
                    localStorage.setItem('lastCenter', JSON.stringify(map.getCenter()));
                    Logger.debug('saveCurrentState', 'State successfully saved.');
                }
            }
            window.saveCurrentState = saveCurrentState;

            saveSettingsBtn.addEventListener('click', () => {
                Logger.debug('saveSettingsBtn.click', 'Toggling save settings state.');
                if (saveSettingsToggleUI.classList.contains('active')) {
                    saveSettingsToggleUI.classList.remove('active');
                    localStorage.clear();
                    document.cookie.split(";").forEach(function(c) { document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); });
                    Logger.info('Setting changed: Save settings disabled & cache cleared');
                    location.reload(); 
                } else {
                    saveSettingsToggleUI.classList.add('active');
                    localStorage.setItem('saveSettings', 'true');
                    saveCurrentState();
                    Logger.info('Setting changed: Save settings enabled');
                    showToast("Settings Saved");
                }
            });

            debugSettingsBtn.addEventListener('click', () => {
                debugModeEnabled = !debugModeEnabled;
                debugSettingsToggleUI.classList.toggle('active');
                saveCurrentState();
                Logger.info(`Setting changed: Debug Mode toggled`, { enabled: debugModeEnabled });
                showToast(`Debug Mode: ${debugModeEnabled ? 'On' : 'Off'}`);
            });

            flySettingsBtn.addEventListener('click', () => {
                flyToRadarSetting = !flyToRadarSetting;
                flySettingsToggleUI.classList.toggle('active');
                saveCurrentState();
                Logger.info('Setting changed: Fly to Radar', { enabled: flyToRadarSetting });
            });

            zoneAlertsBtn.addEventListener('click', () => {
                zoneAlertsEnabled = !zoneAlertsEnabled;
                zoneAlertsToggleUI.classList.toggle('active');
                saveCurrentState();
                Logger.info('Setting changed: Zone Alerts', { enabled: zoneAlertsEnabled });
                if (zoneAlertsEnabled && alertsEnabled) {
                    showToast("Zone Alerts: On");
                    updateZoneAlerts(true);
                } else if (!zoneAlertsEnabled) {
                    showToast("Zone Alerts: Off");
                    if (map.getSource('alerts-zone')) map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: [] });
                    globalZoneAlerts = [];
                    alertQueue = alertQueue.filter(item => item.feature.properties.geometryType !== 'zone');
                    activeAlertFlashes.forEach((value, key) => {
                        if (value.type === 'zone') {
                            clearTimeout(value.timeoutId);
                            if (map.getLayer(value.borderHighlightId)) map.removeLayer(value.borderHighlightId);
                            if (map.getLayer(value.highlightId)) map.removeLayer(value.highlightId);
                            if (map.getSource(value.highlightId)) map.removeSource(value.highlightId);
                            activeAlertFlashes.delete(key);
                        }
                    });
                }
            });

            const sidebar = document.getElementById('sidebar');
            const sidebarOverlay = document.getElementById('sidebar-overlay');
            const menuBtn = document.getElementById('pill-menu-btn');
            const closeBtn = document.getElementById('sidebar-close-btn');
            const sbSettingsBtn = document.getElementById('sidebar-settings-btn');
            const sbMosaicBtn = document.getElementById('sidebar-mosaic-btn');
            const sbAlertsBtn = document.getElementById('sidebar-alerts-btn');
            const sbSitesBtn = document.getElementById('sidebar-sites-btn');
            const debugInput = document.getElementById('debug-file-input');
            const settingsOverlay = document.getElementById('settings-overlay');
            const settingsCloseBtn = settingsOverlay.querySelector('.maplibregl-popup-close-button');
            const pillInfoBtn = document.getElementById('pill-info-btn');

            sidebar.addEventListener('contextmenu', disableContextMenu);
            menuBtn.addEventListener('contextmenu', disableContextMenu);

            function openSidebar() { Logger.debug('openSidebar', 'Opening sidebar UI'); sidebar.classList.add('open'); sidebarOverlay.style.display = 'block'; }
            function closeSidebar() { Logger.debug('closeSidebar', 'Closing sidebar UI'); sidebar.classList.remove('open'); sidebarOverlay.style.display = 'none'; document.querySelectorAll('.sidebar-dropdown-container.show').forEach(el => { el.classList.remove('show'); }); document.querySelectorAll('.sidebar-menu-item.active').forEach(el => { el.classList.remove('active'); }); document.querySelectorAll('.settings-item.active').forEach(el => { el.classList.remove('active'); }); }
            menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openSidebar(); });
            closeBtn.addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);
            sbMosaicBtn.addEventListener('click', () => { radarToggle.checked = !radarToggle.checked; Logger.info('Setting changed: Mosaic Visibility', { checked: radarToggle.checked }); updateMosaicVisibility(); saveCurrentState(); });
            sbAlertsBtn.addEventListener('click', () => { Logger.debug('sbAlertsBtn.click', 'Toggling all alerts from sidebar'); toggleAllAlerts(); });
            sbSitesBtn.addEventListener('click', () => { sitesToggle.checked = !sitesToggle.checked; Logger.info('Setting changed: Sites Visibility', { checked: sitesToggle.checked }); if (map.getLayer(layerIds.radarSites)) map.setLayoutProperty(layerIds.radarSites, 'visibility', sitesToggle.checked ? 'visible' : 'none'); saveCurrentState(); });
            sbSettingsBtn.addEventListener('click', () => { Logger.debug('sbSettingsBtn.click', 'Opening settings overlay'); closeSidebar(); settingsOverlay.style.display = 'flex'; });
            settingsCloseBtn.addEventListener('click', () => { Logger.debug('settingsCloseBtn.click', 'Closing settings overlay'); settingsOverlay.style.display = 'none'; });
            settingsOverlay.addEventListener('click', (e) => { if (e.target === settingsOverlay) { Logger.debug('settingsOverlay.click', 'Closing settings overlay via background tap'); settingsOverlay.style.display = 'none'; } });

            siteSelectOptions.forEach(option => {
                option.addEventListener('click', () => {
                    radarSiteSelectionMode = option.dataset.value;
                    Logger.info('Setting changed: Site Selection Mode', { mode: radarSiteSelectionMode });
                    showToast(`Site Selection: ${radarSiteSelectionMode}`);
                    siteSelectOptions.forEach(opt => opt.style.background = 'transparent');
                    option.style.background = 'rgba(255, 255, 255, 0.2)';
                    saveCurrentState();
                });
            });

            const sidebarOutlookBtns = document.querySelectorAll('.sidebar-menu-item.outlook-type');
            sidebarOutlookBtns.forEach(btn => { btn.addEventListener('click', () => { activeSpcDay = btn.dataset.day; activeSpcType = btn.dataset.type; Logger.info('Setting changed: SPC Outlook', { day: activeSpcDay, type: activeSpcType }); updateSpcLayerVisibility(); saveCurrentState(); closeSidebar(); }); });
            debugInput.addEventListener('change', handleDebugUpload);

            pillInfoBtn.addEventListener('click', () => {
                Logger.debug('pillInfoBtn.click', 'Iterating radar products for active site', { activeSiteIdForData, activeRadarProductCode });
                if (!activeSiteIdForData || !activeRadarProductCode) return;
                const site = allRadarSitesData.find(s => s.properties.id.toLowerCase() === activeSiteIdForData);
                if (!site) return;
                const type = site.properties.stationType;
                let next;
                if (type === 'TDWR') {
                    if (activeRadarProductCode === 'bref1') next = 'brefl';
                    else if (activeRadarProductCode === 'brefl') next = 'bvel';
                    else next = 'bref1';
                } else { next = (activeRadarProductCode === 'sr_bref') ? 'sr_bvel' : 'sr_bref'; }
                toggleRadarProduct(activeSiteIdForData, next);
            });

            const fullAlertOverlay = document.createElement('div');
            fullAlertOverlay.id = 'full-alert-text-popup-overlay';
            fullAlertOverlay.innerHTML = `<div id="full-alert-text-popup"><button class="maplibregl-popup-close-button" type="button" aria-label="Close popup" aria-hidden="true">Ã—</button><div id="full-alert-text-content"></div></div>`;
            document.body.appendChild(fullAlertOverlay);
            fullAlertOverlay.addEventListener('contextmenu', disableContextMenu);
            fullAlertOverlay.style.display = 'none'; 
            document.querySelector('#full-alert-text-popup .maplibregl-popup-close-button').addEventListener('click', () => { Logger.debug('fullAlertTextPopup.close', 'Closing full text popup'); fullAlertOverlay.style.display = 'none'; });
            fullAlertOverlay.addEventListener('click', (e) => { if (e.target === fullAlertOverlay) { Logger.debug('fullAlertOverlay.click', 'Closing full text popup via overlay tap'); fullAlertOverlay.style.display = 'none'; } });
            
            const attributionBubble = document.getElementById('attribution-bubble');
            attributionBubble.addEventListener('click', (event) => { Logger.debug('attributionBubble.click', 'Toggled attribution bubble visibility'); event.stopPropagation(); attributionBubble.classList.toggle('expanded'); });
            
            if (saveSettingsEnabled && urlParams.get('s')) { saveCurrentState(); }
        });

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            center: [-97, 39],
            zoom: 3,
            attributionControl: false
        });

        const layerIds = {
            radar: 'weather-radar-layer', alertsZone: 'alerts-zone-layer', alertsZoneBorder: 'alerts-zone-border-layer', alertsPolygon: 'alerts-polygon-layer', alertsPolygonBorder: 'alerts-polygon-border-layer', radarSites: 'nws-radar-sites-layer', singleSiteRadar: 'single-site-radar-layer',
            spc: { day1: { cat: 'spc-day1-cat', torn: 'spc-day1-torn', hail: 'spc-day1-hail', wind: 'spc-day1-wind' }, day2: { cat: 'spc-day2-cat', torn: 'spc-day2-torn', hail: 'spc-day2-hail', wind: 'spc-day2-wind' }, day3: { cat: 'spc-day3-cat', prob: 'spc-day3-prob' }, day4: { prob: 'spc-day4-prob' }, day5: { prob: 'spc-day5-prob' }, day6: { prob: 'spc-day6-prob' }, day7: { prob: 'spc-day7-prob' }, day8: { prob: 'spc-day8-prob' } }
        };

        let currentMapPopup = null; 
        let allRadarSitesData = []; 
        let currentStackedAlertsOnMap = []; 
        let currentStackedAlertIndex = 0;
        let globalPolyAlerts = [];
        let globalZoneAlerts = [];
        let alertQueue = [], seenAlerts = new Set(), isDisplayingAlert = false, isInitialLoad = true;
        let activeAlertFlashes = new Map();
        let updateIntervalId = null;

        const baseSpcLayerIds = Object.values(layerIds.spc).flatMap(day => Object.values(day));
        const allSpcLayerIds = baseSpcLayerIds.flatMap(id => [id, `${id}-border`]);
        const spcSources = [
            { id: layerIds.spc.day1.cat, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day1.torn, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day1.hail, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day1.wind, url: 'https://www.spc.noaa.gov/products/outlook/day1otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day2.cat, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day2.torn, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_torn.nolyr.geojson' }, { id: layerIds.spc.day2.hail, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_hail.nolyr.geojson' }, { id: layerIds.spc.day2.wind, url: 'https://www.spc.noaa.gov/products/outlook/day2otlk_wind.nolyr.geojson' },
            { id: layerIds.spc.day3.cat, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_cat.nolyr.geojson' }, { id: layerIds.spc.day3.prob, url: 'https://www.spc.noaa.gov/products/outlook/day3otlk_prob.nolyr.geojson' },
            { id: layerIds.spc.day4.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day4prob.nolyr.geojson' }, { id: layerIds.spc.day5.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day5prob.nolyr.geojson' }, { id: layerIds.spc.day6.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day6prob.nolyr.geojson' }, { id: layerIds.spc.day7.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day7prob.nolyr.geojson' }, { id: layerIds.spc.day8.prob, url: 'https://www.spc.noaa.gov/products/exper/day4-8/day8prob.nolyr.geojson' }
        ];

        function getAlertColor(props) {
            Logger.debug('getAlertColor', 'Determining specific color for event', { event: props.event });
            const event = props.event, params = props.parameters || {};
            if (event === 'Tornado Warning') {
                const threat = params.tornadoDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return '#E066FF';
                if (threat === 'CONSIDERABLE') return '#FF66CC';
                return '#FF0000';
            }
            if (event === 'Severe Thunderstorm Warning') {
                const threat = params.thunderstormDamageThreat?.[0];
                if (threat === 'DESTRUCTIVE') return '#FF7000';
                if (threat === 'CONSIDERABLE') return '#FF9000';
                if (params.tornadoDetection?.[0] === 'POSSIBLE') return '#FFA020';
                return '#FFA500';
            }
            return alertColorMap[event] || '#808080';
        }

        function getAlertBorderWidth(props, isPoly) {
            Logger.debug('getAlertBorderWidth', 'Determining border width for alert', { isPoly });
            const params = props.parameters || {};
            const allParams = Object.values(params).flat().map(v => String(v).toUpperCase());
            if (allParams.includes('CATASTROPHIC') || allParams.includes('DESTRUCTIVE')) return 4;
            if (allParams.includes('CONSIDERABLE')) return 3;
            return isPoly ? 2 : 1;
        }

        function hexToRgba(hex, alpha) { 
            Logger.debug('hexToRgba', 'Converting hex color to rgba format', { hex, alpha });
            if (!hex) return `rgba(128, 128, 128, ${alpha})`; 
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); 
            return `rgba(${r}, ${g}, ${b}, ${alpha})`; 
        }

        function parseApiDate(dateString) { 
            Logger.debug('parseApiDate', 'Parsing date string from API', { dateString });
            return new Date(dateString); 
        }
        
        function getSpecificAlertName(props) {
            Logger.debug('getSpecificAlertName', 'Evaluating specific threat tags for specific name', { event: props.event });
            const event = props.event, params = props.parameters || {};
            if (event === 'Tornado Warning') {
                const threat = params.tornadoDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Tornado';
                if (threat === 'CONSIDERABLE') return 'Considerable Tornado';
                if (params.tornadoDetection?.[0] === 'OBSERVED') return 'Confirmed Tornado';
            }
            if (event === 'Severe Thunderstorm Warning') {
                const threat = params.thunderstormDamageThreat?.[0];
                if (threat === 'DESTRUCTIVE') return 'Destructive Thunderstorm';
                if (threat === 'CONSIDERABLE') return 'Considerable Thunderstorm';
                if (params.tornadoDetection?.[0] === 'POSSIBLE') return 'Tornado Possible';
            }
            if (event === 'Special Marine Warning' || event === 'Marine Weather Statement') {
                 const threat = params.waterspoutDetection?.[0];
                 if (threat === 'OBSERVED') return 'Confirmed Waterspout';
                 if (threat === 'POSSIBLE') return 'Waterspout Possible';
            }
            if (event === 'Flash Flood Warning') {
                const threat = params.flashFloodDamageThreat?.[0];
                if (threat === 'CATASTROPHIC') return 'Catastrophic Flash Flood';
                if (threat === 'CONSIDERABLE') return 'Considerable Flash Flood';
            }
            return event;
        }

        function isValidAlert(feature) {
            Logger.debug('isValidAlert', 'Validating alert feature object', { id: feature.properties?.id });
            const props = feature.properties;
            if (!props) return false;
            if (props.parameters && props.parameters.VTEC && props.parameters.VTEC[0] && props.parameters.VTEC[0].startsWith("/O.CAN.")) return false;
            return true;
        }
        
        function formatThreatValue(value) { 
            Logger.debug('formatThreatValue', 'Formatting threat value casing', { value });
            if (!value || typeof value !== 'string') return ''; 
            const cleanedValue = value.toUpperCase() === 'N/A' ? '' : value; 
            if (!cleanedValue) return ''; 
            return cleanedValue.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '); 
        }
        
        function flashAlertOnMap(feature, duration = 10000) {
            Logger.debug('flashAlertOnMap', 'Initiating map alert visual flash', { id: feature?.properties?.id, duration });
            if (!feature || !feature.geometry || !feature.properties || !feature.properties.id) {
                Logger.error('flashAlertOnMap', new Error('Missing feature or geometry data'), { feature });
                return;
            }
            const alertId = feature.properties.id, now = Date.now(), existingFlash = activeAlertFlashes.get(alertId);
            if (existingFlash) {
                if (existingFlash.endTime - now > 3000) return;
                else { 
                    clearTimeout(existingFlash.timeoutId); 
                    if (map.getLayer(existingFlash.borderHighlightId)) map.removeLayer(existingFlash.borderHighlightId); 
                    if (map.getLayer(existingFlash.highlightId)) map.removeLayer(existingFlash.highlightId); 
                    if (map.getSource(existingFlash.highlightId)) map.removeSource(existingFlash.highlightId); 
                    activeAlertFlashes.delete(alertId); 
                }
            }
            const highlightId = 'highlight-' + alertId + '-' + now, borderHighlightId = highlightId + '-border';
            map.addSource(highlightId, { 'type': 'geojson', 'data': feature });
            const bw = feature.properties.borderWidth || (feature.properties.geometryType === 'polygon' ? 2 : 1);
            map.addLayer({ 'id': highlightId, 'type': 'fill', 'source': highlightId, 'paint': { 'fill-opacity': 0, 'fill-opacity-transition': { duration: 450 } } });
            map.addLayer({ 'id': borderHighlightId, 'type': 'line', 'source': highlightId, 'paint': { 'line-color': '#ffffff', 'line-width': bw, 'line-opacity': 0, 'line-opacity-transition': { duration: 450 } } });
            const setOpacity = (f, l) => { 
                if (map.getLayer(highlightId)) map.setPaintProperty(highlightId, 'fill-opacity', f); 
                if (map.getLayer(borderHighlightId)) map.setPaintProperty(borderHighlightId, 'line-opacity', l); 
            };
            const count = Math.floor(duration / 2000);
            for (let i = 0; i < count; i++) { 
                setTimeout(() => setOpacity(0.25, 0.9), i * 2000); 
                setTimeout(() => setOpacity(0, 0), i * 2000 + 1000); 
            }
            const timeoutId = setTimeout(() => { 
                if (map.getLayer(borderHighlightId)) map.removeLayer(borderHighlightId); 
                if (map.getLayer(highlightId)) map.removeLayer(highlightId); 
                if (map.getSource(highlightId)) map.removeSource(highlightId); 
                activeAlertFlashes.delete(alertId); 
            }, duration + 500);
            activeAlertFlashes.set(alertId, { timeoutId, endTime: now + duration + 500, highlightId, borderHighlightId, type: feature.properties.geometryType });
        }

        function flyToAlert(feature) {
            if (!feature || !feature.geometry || !feature.geometry.coordinates) return;
            const bounds = new maplibregl.LngLatBounds();
            try {
                const processCoords = (coords) => { for(const coord of coords) { if (Array.isArray(coord[0])) processCoords(coord); else bounds.extend(coord); } };
                processCoords(feature.geometry.coordinates);
                if (bounds.getNorthEast() && bounds.getSouthWest()) { 
                    Logger.debug('flyToAlert', 'Flying camera to alert location', { id: feature.properties.id, bounds: [bounds.getSouthWest().toArray(), bounds.getNorthEast().toArray()] });
                    map.fitBounds(bounds, { padding: 150, essential: true }); 
                    map.once('moveend', () => flashAlertOnMap(feature, 6000)); 
                }
            } catch(e) { Logger.error('flyToAlert', e, { feature }); }
        }

        function createAndShowAlertPopup(feature, source) {
            Logger.debug('createAndShowAlertPopup', 'Generating lower left alert toast', { id: feature.properties.id, source });
            const props = feature.properties, params = props.parameters || {}, container = document.getElementById('alert-popup-container');
            const popup = document.createElement('div');
            popup.className = 'alert-popup';
            
            const specificAlertName = props.specificEventName, baseEvent = props.event, accentColor = props.displayColor || '#808080';
            let title = (source === 'new' && props.messageType === 'Update' ? 'Updated - ' : '') + specificAlertName, detailsHTML = '<div>';
            const expireDate = parseApiDate(props.expires);
            if (expireDate && !isNaN(expireDate.getTime())) { detailsHTML += `<p><strong>Expires:</strong> ${expireDate.toLocaleString('en-US', { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true })}</p>`; }
            if (props.areaDesc && props.areaDesc.toUpperCase() !== 'N/A') detailsHTML += `<p><strong>Affected:</strong> ${props.areaDesc}</p>`;
            if (params.tornadoDetection && formatThreatValue(params.tornadoDetection[0])) detailsHTML += `<p><strong>Tornado:</strong> ${formatThreatValue(params.tornadoDetection[0])}</p>`;
            if (params.waterspoutDetection && formatThreatValue(params.waterspoutDetection[0])) detailsHTML += `<p><strong>Waterspout:</strong> ${formatThreatValue(params.waterspoutDetection[0])}</p>`;
            const dmg = params.tornadoDamageThreat?.[0] || params.thunderstormDamageThreat?.[0] || params.flashFloodDamageThreat?.[0];
            if (dmg && formatThreatValue(dmg)) detailsHTML += `<p><strong>Threat:</strong> ${formatThreatValue(dmg)}</p>`;
            if (params.maxWindGust && params.maxWindGust[0] !== '0 MPH' && formatThreatValue(params.maxWindGust[0])) { detailsHTML += `<p><strong>Winds:</strong> ${params.maxWindGust[0].replace("MPH", "mph")}${params.windThreat && formatThreatValue(params.windThreat[0]) ? ', ' + formatThreatValue(params.windThreat[0]) : ''}</p>`; }
            if (params.maxHailSize && params.maxHailSize[0] !== '0.00' && formatThreatValue(params.maxHailSize[0])) { detailsHTML += `<p><strong>Hail:</strong> ${params.maxHailSize[0]}"${params.hailThreat && formatThreatValue(params.hailThreat[0]) ? ', ' + formatThreatValue(params.hailThreat[0]) : ''}</p>`; }
            if (params.flashFloodDetection && formatThreatValue(params.flashFloodDetection[0])) detailsHTML += `<p><strong>Source:</strong> ${formatThreatValue(params.flashFloodDetection[0])}</p>`;
            popup.style.borderLeft = `5px solid ${hexToRgba(accentColor, 0.5)}`; popup.innerHTML = `<h4>${title}</h4>${detailsHTML}</div>`; popup.addEventListener('click', () => flyToAlert(feature));
            container.appendChild(popup); setTimeout(() => popup.classList.add('fly-in'), 10);
            setTimeout(() => { popup.classList.remove('fly-in'); popup.classList.add('fly-out'); }, 7000);
            setTimeout(() => { popup.remove(); if (source === 'new') { setTimeout(() => { isDisplayingAlert = false; displayNextAlert(); }, 1000); } }, 7500);
        }

        function displayNextAlert() { 
            Logger.debug('displayNextAlert', 'Attempting to dequeue and display next alert', { queueSize: alertQueue.length, isDisplayingAlert, alertsEnabled });
            if (isDisplayingAlert || alertQueue.length === 0 || !alertsEnabled) return; 
            const nextItem = alertQueue[0];
            if (nextItem.feature.properties.geometryType === 'zone' && !zoneAlertsEnabled) {
                Logger.debug('displayNextAlert', 'Skipping zone alert because setting is off');
                alertQueue.shift(); 
                displayNextAlert();
                return;
            }
            isDisplayingAlert = true; 
            const { feature } = alertQueue.shift(); 
            flashAlertOnMap(feature, 10000); 
            createAndShowAlertPopup(feature, 'new'); 
        }

        function addNewAlertToQueue(feature, type, isSilent = false) { 
            Logger.debug('addNewAlertToQueue', 'Enqueuing new alert if not seen', { id: feature.properties.id, isSilent });
            const id = feature.properties.id;
            if (!seenAlerts.has(id)) { 
                seenAlerts.add(id); 
                if (!isInitialLoad && !isSilent && alertsEnabled) {
                    alertQueue.push({ feature, type }); 
                }
            } 
            if (!isInitialLoad && !isSilent && alertsEnabled) displayNextAlert(); 
        }

        async function processRawAlertFeatures(raw, filterType, isSilent = false) {
            Logger.debug('processRawAlertFeatures', 'Sorting and formatting raw alert payloads', { rawCount: raw.length, filterType, isSilent });
            const valid = raw.filter(isValidAlert), poly = [], zone = [];
            valid.forEach(f => { 
                f.properties.specificEventName = getSpecificAlertName(f.properties); 
                f.properties.displayColor = getAlertColor(f.properties);
                const isPoly = !!f.geometry;
                f.properties.borderWidth = getAlertBorderWidth(f.properties, isPoly);
                if (isPoly) { f.properties.geometryType = 'polygon'; poly.push(f); } else zone.push(f); 
            });

            if (filterType === 'polygon') {
                if (map.getSource('alerts-poly')) map.getSource('alerts-poly').setData({ type: 'FeatureCollection', features: poly });
                globalPolyAlerts = poly; poly.forEach(f => addNewAlertToQueue(f, 'alert', isSilent));
            } else if (filterType === 'zone') {
                if (zoneAlertsEnabled) {
                    await processZoneAlerts(zone, isSilent);
                } else {
                    if (map.getSource('alerts-zone')) map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: [] });
                    globalZoneAlerts = [];
                }
            }
        }

        function handleDebugUpload(e) {
            Logger.debug('handleDebugUpload', 'Handling uploaded debug file triggered via UI');
            const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    Logger.info('Parsing uploaded debug file payload');
                    const data = JSON.parse(ev.target.result); if (!data.features) throw new Error(); if (updateIntervalId) clearInterval(updateIntervalId); isInitialLoad = false;
                    data.features.forEach(f => { if (!f.properties.id) f.properties.id = "debug_" + Math.random().toString(36).substr(2, 9); });
                    await processRawAlertFeatures(data.features, 'polygon', false);
                    await processRawAlertFeatures(data.features, 'zone', false);
                    const firstPoly = data.features.find(f => f.geometry); if (firstPoly) flyToAlert(firstPoly);
                } catch (err) { Logger.error('handleDebugUpload', err); alert("Error parsing GeoJSON."); }
            }; reader.readAsText(file);
        }

        function updateMosaicVisibility() {
            Logger.debug('updateMosaicVisibility', 'Updating composite radar visibility logic');
            const mosaicOn = document.getElementById('radar-toggle').checked, siteActive = map.getLayer(layerIds.singleSiteRadar);
            const targetState = siteActive ? 'none' : (mosaicOn ? 'visible' : 'none');
            if (map.getLayer(layerIds.radar)) map.setLayoutProperty(layerIds.radar, 'visibility', targetState);
        }

        function removeSingleSiteLayer() { 
            Logger.debug('removeSingleSiteLayer', 'Clearing single site layer from map');
            if (map.getLayer(layerIds.singleSiteRadar)) map.removeLayer(layerIds.singleSiteRadar); if (map.getSource('single-site-radar-source')) map.removeSource('single-site-radar-source'); document.getElementById('radar-info-pill').style.display = 'none'; 
        }

        function closeAllPopups() { 
            Logger.debug('closeAllPopups', 'Destroying all active map popups');
            const popups = document.querySelectorAll('.maplibregl-popup'); popups.forEach(p => p.remove()); currentMapPopup = null; currentStackedAlertsOnMap = []; currentStackedAlertIndex = 0; document.getElementById('full-alert-text-popup-overlay').style.display = 'none'; 
        }

        function toggleRadarProduct(stationId, productCode) {
            Logger.debug('toggleRadarProduct', 'Switching active radar site data layer', { stationId, productCode });
            const togglingOff = activeSiteIdForData === stationId && activeRadarProductCode === productCode;
            removeSingleSiteLayer();
            if (togglingOff) { activeRadarProductCode = null; activeSiteIdForData = null; map.setPaintProperty(layerIds.radarSites, 'circle-color', radarSiteDefaultColor); }
            else {
                activeRadarProductCode = productCode; activeSiteIdForData = stationId;
                const tileUrl = `https://opengeo.ncep.noaa.gov/geoserver/${stationId}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${stationId}_${productCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`;
                map.addSource('single-site-radar-source', { 'type': 'raster', 'tiles': [tileUrl], 'tileSize': 256, 'attribution': 'NOAA' });
                map.addLayer({ 'id': layerIds.singleSiteRadar, 'type': 'raster', 'source': 'single-site-radar-source', 'paint': {} }, layerIds.alertsZone); 
                map.setPaintProperty(layerIds.radarSites, 'circle-color', ['case', ['==', ['get', 'id'], stationId.toUpperCase()], '#00ff00', ['==', ['get', 'statusError'], true], '#8800FF', ['==', ['get', 'isOffline'], true], '#ff0000', ['==', ['get', 'stationType'], 'WSR-88D'], '#0099ff', ['==', ['get', 'stationType'], 'TDWR'], '#ff9900', '#808080']);
                updateRadarPillUI(stationId, productCode);
            }
            updateMosaicVisibility(); if (window.saveCurrentState) window.saveCurrentState();
        }

        function updateRadarPillUI(id, code) {
            Logger.debug('updateRadarPillUI', 'Modifying single site info pill', { id, code });
            const pillId = document.getElementById('pill-id-time'), pillProd = document.getElementById('pill-product'); pillId.innerText = id.toUpperCase();
            let label = "Reflectivity"; if (code.includes('vel')) label = "Velocity"; else if (code === 'brefl') label = "LR Reflectivity";
            pillProd.innerText = label; document.getElementById('radar-info-pill').style.display = 'flex';
        }

        async function updatePolygonAlerts(isSilent = false) { 
            const start = performance.now();
            Logger.debug('updatePolygonAlerts', 'Querying api.weather.gov for polygons', { isSilent });
            try { 
                const response = await fetch('https://api.weather.gov/alerts/active?status=actual&message_type=alert,update'); 
                const data = await response.json(); 
                Logger.debug('updatePolygonAlerts', 'API Fetch successful', { totalReturned: data.features.length, fetchTimeMs: (performance.now() - start).toFixed(2) });
                await processRawAlertFeatures(data.features, 'polygon', isSilent); 
                Logger.debug('updatePolygonAlerts', 'Polygon update complete', { totalTimeMs: (performance.now() - start).toFixed(2) });
                if (isInitialLoad) isInitialLoad = false;
            } catch (e) { Logger.error('updatePolygonAlerts', e); } 
        }

        async function updateZoneAlerts(isSilent = false) { 
            const start = performance.now();
            Logger.debug('updateZoneAlerts', 'Querying api.weather.gov for zone alerts', { isSilent });
            try { 
                const response = await fetch('https://api.weather.gov/alerts/active?status=actual&message_type=alert,update'); 
                const data = await response.json(); 
                Logger.debug('updateZoneAlerts', 'API Fetch successful', { totalReturned: data.features.length, fetchTimeMs: (performance.now() - start).toFixed(2) });
                await processRawAlertFeatures(data.features, 'zone', isSilent); 
                Logger.debug('updateZoneAlerts', 'Zone update complete', { totalTimeMs: (performance.now() - start).toFixed(2) });
            } catch (e) { Logger.error('updateZoneAlerts', e); } 
        }

        async function processZoneAlerts(features, isSilent = false) {
            const startZone = performance.now();
            Logger.debug('processZoneAlerts', 'Translating zone alert codes to geometry via endpoints', { totalToProcess: features.length });
            const tasks = features.flatMap(f => {
                if (!f.properties.affectedZones) return [];
                return f.properties.affectedZones.map(url => ({ url, parentFeature: f }));
            });

            const resolvedFeatures = [];
            const featureGeometryMap = new Map();
            const chunkPromises = [];

            for (let i = 0; i < tasks.length; i += 25) {
                const chunk = tasks.slice(i, i + 25);
                Logger.debug('processZoneAlerts', `Fetching zone block ${Math.floor(i/25) + 1}`, { startIdx: i, size: chunk.length });
                
                chunkPromises.push(Promise.all(chunk.map(async (task) => {
                    const reqStart = performance.now();
                    try { 
                        const res = await fetch(task.url);
                        Logger.debug('processZoneAlerts.fetch', 'Zone block request finished', { status: res.status, url: task.url, timeMs: (performance.now() - reqStart).toFixed(2) });
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        const data = await res.json();
                        if (data.geometry) {
                            const alertId = task.parentFeature.properties.id;
                            if (!featureGeometryMap.has(alertId)) featureGeometryMap.set(alertId, []);
                            if (data.geometry.type === 'Polygon') featureGeometryMap.get(alertId).push(data.geometry.coordinates);
                            else if (data.geometry.type === 'MultiPolygon') featureGeometryMap.get(alertId).push(...data.geometry.coordinates);
                        }
                    } catch (e) { Logger.error('processZoneAlerts.fetchChunk', e, { taskUrl: task.url }); }
                })));
            }

            await Promise.all(chunkPromises);

            features.forEach(f => {
                const alertId = f.properties.id;
                const geoms = featureGeometryMap.get(alertId) || [];
                if (geoms.length > 0) {
                    const finalFeature = { type: 'Feature', geometry: { type: 'MultiPolygon', coordinates: geoms }, properties: { ...f.properties, geometryType: 'zone' } };
                    resolvedFeatures.push(finalFeature);
                    addNewAlertToQueue(finalFeature, 'alert', isSilent);
                }
            });

            Logger.debug('processZoneAlerts', 'Finished translating geometries', { successCount: resolvedFeatures.length, totalTimeMs: (performance.now() - startZone).toFixed(2) });
            if (map.getSource('alerts-zone')) map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: resolvedFeatures });
            globalZoneAlerts = resolvedFeatures;
        }

        async function checkRadarStatus() {
            const t = performance.now();
            Logger.debug('checkRadarStatus', 'Pinging site statuses from NWS');
            const now = Date.now(), twenty = now - 1200000; let changed = false, updated = [...allRadarSitesData];
            for (let i = 0; i < updated.length; i++) {
                const site = updated[i], radarId = site.properties.id;
                try {
                    const res = await fetch(`https://api.weather.gov/radar/stations/${radarId}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`); 
                    const data = await res.json(), lastTime = data.properties.latency?.levelTwoLastReceivedTime;
                    let offline = lastTime ? (new Date(lastTime).getTime() < twenty) : true;
                    if (site.properties.isOffline !== offline || site.properties.statusError !== false) { 
                        updated[i] = { ...site, properties: { ...site.properties, isOffline: offline, statusError: false } }; 
                        changed = true; 
                    }
                } catch (e) { 
                    Logger.error('checkRadarStatus.pingSite', e, { radarId });
                    if (site.properties.statusError !== true) {
                        updated[i] = { ...site, properties: { ...site.properties, statusError: true, isOffline: false } }; 
                        changed = true; 
                    }
                }
            }
            allRadarSitesData = updated; 
            if (changed && map.getSource('radar-sites')) {
                Logger.debug('checkRadarStatus', 'Radar statuses updated on map points');
                map.getSource('radar-sites').setData({ type: 'FeatureCollection', features: allRadarSitesData });
                if (activeSiteIdForData) map.setPaintProperty(layerIds.radarSites, 'circle-color', ['case', ['==', ['get', 'id'], activeSiteIdForData.toUpperCase()], '#00ff00', ...radarSiteDefaultColor.slice(1)]);
                else map.setPaintProperty(layerIds.radarSites, 'circle-color', radarSiteDefaultColor);
            }
            Logger.debug('checkRadarStatus', 'Ping complete', { timeMs: (performance.now() - t).toFixed(2) });
        }

        async function fetchSpcOutlookText(day) {
            Logger.debug('fetchSpcOutlookText', 'Fetching parsed SPC textual outlook', { day });
            let url = (parseInt(day) >= 4) ? 'https://www.spc.noaa.gov/products/exper/day4-8/index.html' : `https://www.spc.noaa.gov/products/outlook/day${day}otlk.html`;
            try {
                const res = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);
                const html = await res.text();
                const pre = new DOMParser().parseFromString(html, 'text/html').querySelector('pre'); 
                Logger.debug('fetchSpcOutlookText', 'Successfully obtained SPC text element');
                return pre ? pre.textContent : "Not found."; 
            } catch (e) { 
                Logger.error('fetchSpcOutlookText', e, { day });
                return "Failed to load."; 
            }
        }

        function updateRadar() { 
            const t = performance.now();
            Logger.debug('updateRadar', 'Re-fetching mosaic base cache');
            if (map.getSource('weather-radar')) {
                const ts = new Date().getTime();
                map.getSource('weather-radar').setTiles([`https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png?_=${ts}`]); 
                Logger.debug('updateRadar', 'Refreshed radar mosaic raster', { timeMs: (performance.now() - t).toFixed(2) });
            }
        }
        function updateSingleSiteRadar() { 
            const t = performance.now();
            Logger.debug('updateSingleSiteRadar', 'Re-fetching single WMS tile');
            if (map.getSource('single-site-radar-source') && activeSiteIdForData && activeRadarProductCode) { 
                const url = `https://opengeo.ncep.noaa.gov/geoserver/${activeSiteIdForData}/ows?service=WMS&version=1.3.0&request=GetMap&layers=${activeSiteIdForData}_${activeRadarProductCode}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}&_=${new Date().getTime()}`; 
                map.getSource('single-site-radar-source').setTiles([url]); 
                Logger.debug('updateSingleSiteRadar', 'Refreshed single site radar raster', { timeMs: (performance.now() - t).toFixed(2) });
            } 
        }
        async function updateSpcOutlooks() { 
            Logger.debug('updateSpcOutlooks', 'Refreshing background SPC vectors');
            for (const s of spcSources) { 
                if (map.getSource(s.id)) { 
                    const sStart = performance.now();
                    try { 
                        const res = await fetch(`${s.url}?t=${new Date().getTime()}`);
                        const data = await res.json(); 
                        map.getSource(s.id).setData(data); 
                        Logger.debug('updateSpcOutlooks', `Refreshed SPC layer`, { id: s.id, timeMs: (performance.now() - sStart).toFixed(2) });
                    } catch (e) { Logger.error('updateSpcOutlooks', e, { sourceId: s.id }); } 
                } 
            } 
        }

        async function setupMapData() {
            Logger.info('Initializing major Map Data elements');
            Logger.debug('setupMapData', 'Adding sources, variables, and geometries');
            let symbolId; for (const l of map.getStyle().layers) { if (l.type === 'symbol') { symbolId = l.id; break; } }
            
            spcSources.forEach(s => { 
                if (!map.getSource(s.id)) {
                    map.addSource(s.id, { type: 'geojson', data: s.url });
                    Logger.info(`Map source loaded: ${s.id}`);
                } 
            });
            
            if (!map.getSource('weather-radar')) {
                map.addSource('weather-radar', { 'type': 'raster', 'tiles': [`https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png`], 'tileSize': 256, 'scheme': 'xyz' });
                Logger.info('Map source loaded: weather-radar');
            }
            if (!map.getSource('alerts-poly')) { map.addSource('alerts-poly', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } }); Logger.info('Map source loaded: alerts-poly'); }
            if (!map.getSource('alerts-zone')) { map.addSource('alerts-zone', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } }); Logger.info('Map source loaded: alerts-zone'); }
            if (allRadarSitesData.length === 0) { 
                try {
                    const res = await fetch('https://api.weather.gov/radar/stations?stationType=WSR-88D,TDWR'), data = await res.json(); 
                    allRadarSitesData = data.features.map(f => ({ ...f, properties: { ...f.properties, isOffline: false, statusError: false } })); 
                } catch (e) { Logger.error('setupMapData', e, { component: 'radar sites metadata' }); }
            }
            if (!map.getSource('radar-sites')) { map.addSource('radar-sites', { type: 'geojson', data: { type: 'FeatureCollection', features: allRadarSitesData } }); Logger.info('Map source loaded: radar-sites'); }
            
            const colorExp = ['coalesce', ['get', 'displayColor'], '#808080'], zBW = ['coalesce', ['get', 'borderWidth'], 1], pBW = ['coalesce', ['get', 'borderWidth'], 2], aVis = alertsEnabled ? 'visible' : 'none';
            if (!map.getLayer(layerIds.alertsZone)) { map.addLayer({ id: layerIds.alertsZone, type: 'fill', source: 'alerts-zone', paint: { 'fill-color': colorExp, 'fill-opacity': 0.1 }, layout: { 'visibility': aVis }, filter: ['==', 'geometryType', 'zone'] }, symbolId); Logger.info(`Map layer loaded: ${layerIds.alertsZone}`); }
            if (!map.getLayer(layerIds.alertsZoneBorder)) { map.addLayer({ id: layerIds.alertsZoneBorder, type: 'line', source: 'alerts-zone', paint: { 'line-color': colorExp, 'line-width': zBW }, layout: { 'visibility': aVis }, filter: ['==', 'geometryType', 'zone'] }, symbolId); Logger.info(`Map layer loaded: ${layerIds.alertsZoneBorder}`); }
            if (!map.getLayer(layerIds.alertsPolygon)) { map.addLayer({ id: layerIds.alertsPolygon, type: 'fill', source: 'alerts-poly', paint: { 'fill-color': colorExp, 'fill-opacity': 0.3 }, layout: { 'visibility': aVis }, filter: ['==', 'geometryType', 'polygon'] }, symbolId); Logger.info(`Map layer loaded: ${layerIds.alertsPolygon}`); }
            if (!map.getLayer(layerIds.alertsPolygonBorder)) { map.addLayer({ id: layerIds.alertsPolygonBorder, type: 'line', source: 'alerts-poly', paint: { 'line-color': colorExp, 'line-width': pBW }, layout: { 'visibility': aVis }, filter: ['==', 'geometryType', 'polygon'] }, symbolId); Logger.info(`Map layer loaded: ${layerIds.alertsPolygonBorder}`); }
            if (!map.getLayer(layerIds.radar)) { map.addLayer({ id: layerIds.radar, type: 'raster', source: 'weather-radar', layout: { 'visibility': document.getElementById('radar-toggle').checked ? 'visible' : 'none' } }, layerIds.alertsZone); Logger.info(`Map layer loaded: ${layerIds.radar}`); }
            
            spcSources.forEach(s => { 
                let isVis = 'none';
                if (activeSpcDay !== 'none' && layerIds.spc['day' + activeSpcDay]) {
                    if (s.id === layerIds.spc['day' + activeSpcDay][activeSpcType]) isVis = 'visible';
                }
                
                if (!map.getLayer(s.id)) { map.addLayer({ id: s.id, type: 'fill', source: s.id, paint: { 'fill-color': ['get', 'fill'], 'fill-opacity': 0.3 }, layout: { 'visibility': isVis } }, layerIds.radar); Logger.info(`Map layer loaded: ${s.id} (initially ${isVis})`); }
                if (!map.getLayer(`${s.id}-border`)) { map.addLayer({ id: `${s.id}-border`, type: 'line', source: s.id, paint: { 'line-color': ['get', 'fill'], 'line-width': 2 }, layout: { 'visibility': isVis } }, layerIds.radar); }
            });
            if (!map.getLayer(layerIds.radarSites)) { map.addLayer({ id: layerIds.radarSites, type: 'circle', source: 'radar-sites', paint: { 'circle-radius': 4, 'circle-stroke-color': 'white', 'circle-stroke-width': 1.5, 'circle-color': radarSiteDefaultColor }, layout: { 'visibility': document.getElementById('radar-sites-toggle').checked ? 'visible' : 'none' } }); Logger.info(`Map layer loaded: ${layerIds.radarSites}`); }
            Logger.debug('setupMapData', 'Map layers mapped and mounted successfully');
        }

        async function toggleAllAlerts() {
            alertsEnabled = !alertsEnabled;
            Logger.info('Setting changed: Alerts Visibility', { enabled: alertsEnabled });
            Logger.debug('toggleAllAlerts', 'Toggling global alert flags', { alertsEnabled });
            if (window.saveCurrentState) window.saveCurrentState();
            if (alertsEnabled) { showToast("Alerts: On"); await Promise.all([updatePolygonAlerts(true), updateZoneAlerts(true)]); } else {
                showToast("Alerts: Off");
                if (map.getSource('alerts-poly')) map.getSource('alerts-poly').setData({ type: 'FeatureCollection', features: [] });
                if (map.getSource('alerts-zone')) map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: [] });
                globalPolyAlerts = []; globalZoneAlerts = []; alertQueue = []; 
                activeAlertFlashes.forEach((value, key) => { clearTimeout(value.timeoutId); if (map.getLayer(value.borderHighlightId)) map.removeLayer(value.borderHighlightId); if (map.getLayer(value.highlightId)) map.removeLayer(value.highlightId); if (map.getSource(value.highlightId)) map.removeSource(value.highlightId); activeAlertFlashes.delete(key); });
            }
            const v = alertsEnabled ? 'visible' : 'none';
            [layerIds.alertsZone, layerIds.alertsZoneBorder, layerIds.alertsPolygon, layerIds.alertsPolygonBorder].forEach(l => { if (map.getLayer(l)) map.setLayoutProperty(l, 'visibility', v); });
        }

        function updateSpcLayerVisibility() { 
            Logger.debug('updateSpcLayerVisibility', 'Processing visual toggles for SPC', { activeSpcDay, activeSpcType });
            if (!map.isStyleLoaded()) return; 
            allSpcLayerIds.forEach(id => { if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none'); }); 
            if (activeSpcDay !== 'none') { 
                const dayObj = layerIds.spc['day' + activeSpcDay];
                if (dayObj) {
                    const target = dayObj[activeSpcType]; 
                    if (target) { 
                        if (map.getLayer(target)) map.setLayoutProperty(target, 'visibility', 'visible'); 
                        if (map.getLayer(`${target}-border`)) map.setLayoutProperty(`${target}-border`, 'visibility', 'visible'); 
                    }
                } 
            } 
        }

        async function geocodeAndPlaceMarker() { 
            Logger.debug('geocodeAndPlaceMarker', 'Inspecting URL params for location marking');
            const loc = new URLSearchParams(window.location.search).get('l'); 
            if (!loc) return; 
            try { 
                const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(loc.replace(/-/g, ' '))}&format=json&limit=1`), data = await res.json(); 
                if (data.length > 0) { 
                    const lon = parseFloat(data[0].lon), lat = parseFloat(data[0].lat); 
                    new maplibregl.Marker({ color: "#FFC300", scale: 0.6 }).setLngLat([lon, lat]).addTo(map); 
                    Logger.debug('geocodeAndPlaceMarker', 'Flying to geocoded location', { coordinates: [lon, lat] });
                    map.flyTo({ center: [lon, lat], zoom: 7, essential: true }); 
                } 
            } catch (e) { Logger.error('geocodeAndPlaceMarker', e, { loc }); } 
        }

        function formatSpcLabel(val) { 
            Logger.debug('formatSpcLabel', 'Formatting outlook category mapping', { val });
            if (!val) return 'N/A'; 
            if (!isNaN(val)) return parseFloat(val) < 1 ? (parseFloat(val) * 100) + "%" : val + "%"; 
            const m = { 'TSTM': 'General Thunderstorms', 'MRGL': 'Marginal', 'SLGT': 'Slight', 'ENH': 'Enhanced', 'MDT': 'Moderate', 'HIGH': 'High' }; 
            return m[val.toUpperCase()] || val; 
        }
        
        function showAlertMapPopup(items, clicked) {
            Logger.debug('showAlertMapPopup', 'Interacted item popup generation begun', { itemsCount: items.length, coords: clicked });
            closeAllPopups(); currentStackedAlertsOnMap = items; currentStackedAlertIndex = 0; const div = document.createElement('div'); div.className = 'map-popup-base map-alert-popup-accent-top'; 
            const update = () => {
                const item = currentStackedAlertsOnMap[currentStackedAlertIndex]; if (!item) { closeAllPopups(); return; }
                const props = item.properties; let title, tags = '', color;
                if (item.type === 'alert') {
                    const params = props.parameters || {}; title = props.specificEventName || props.event; color = props.displayColor || '#808080';
                    if (props.expires) tags += `<p><strong>Expires:</strong> ${new Date(props.expires).toLocaleString('en-US', { timeZone: 'America/Chicago', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true })}</p>`;
                    ['tornadoDetection', 'waterspoutDetection', 'flashFloodDetection'].forEach(k => { if (params[k]) { let label = k.replace('Detection','').replace('flash','Flash '); label = (label === 'tornado') ? 'Tornado' : label.charAt(0).toUpperCase() + label.slice(1); tags += `<p><strong>${label}:</strong> ${formatThreatValue(params[k][0])}</p>`; } });
                    const dmg = params.tornadoDamageThreat?.[0] || params.thunderstormDamageThreat?.[0] || params.flashFloodDamageThreat?.[0]; if (dmg) tags += `<p><strong>Threat:</strong> ${formatThreatValue(dmg)}</p>`;
                    if (params.maxWindGust && params.maxWindGust[0] !== '0 MPH') tags += `<p><strong>Winds:</strong> ${params.maxWindGust[0].replace("MPH", "mph")}</p>`;
                    if (params.maxHailSize && params.maxHailSize[0] !== '0.00') tags += `<p><strong>Hail:</strong> ${params.maxHailSize[0]}"</p>`;
                } else { title = `SPC Day ${activeSpcDay} Outlook`; color = props.fill || '#FFFFFF'; tags += `<p><strong>Risk:</strong> ${formatSpcLabel(props.LABEL || props.LABEL2)}</p>`; }
                div.style.borderTop = `5px solid ${hexToRgba(color, 0.5)}`; let pager = (currentStackedAlertsOnMap.length > 1) ? `<div class="alert-pager">${currentStackedAlertsOnMap.map((_, i) => `<div class="pager-dot ${i === currentStackedAlertIndex ? 'active' : ''}" data-index="${i}"></div>`).join('')}</div>` : '';
                div.innerHTML = `<h4>${title}</h4><div class="popup-content-area">${tags}<ul><li><button id="full-text-button">Full Text</button></li></ul></div>${pager}`;
                const fullTextBtn = div.querySelector('#full-text-button');
                fullTextBtn.addEventListener('click', (e) => { e.stopPropagation(); Logger.debug('fullTextBtn.click', 'Opening full text module inside popup logic'); if (item.type === 'alert') showFullAlertTextPopup(item.feature); else showFullSpcTextPopup(item); });
                div.querySelectorAll('.pager-dot').forEach(d => d.onclick = (e) => { Logger.debug('pagerDot.click', 'Navigated stacked alerts container'); currentStackedAlertIndex = parseInt(e.target.dataset.index); update(); });
            }; update(); currentMapPopup = new maplibregl.Popup({ closeOnClick: true, closeButton: false, anchor: 'bottom', className: 'custom-map-popup-container' }).setLngLat(clicked).setDOMContent(div).addTo(map);
        }

        async function showFullAlertTextPopup(f) {
            Logger.debug('showFullAlertTextPopup', 'Parsing NWS text component for popup', { specificEvent: f.properties.specificEventName });
            const props = f.properties, overlay = document.getElementById('full-alert-text-popup-overlay'), rgba = hexToRgba(props.displayColor || '#808080', 0.5), el = document.getElementById('full-alert-text-popup');
            el.style.borderLeft = el.style.borderTop = el.style.borderRight = `5px solid ${rgba}`;
            const formattedD = formatNwsText(props.description), formattedI = formatNwsText(props.instruction);
            let isWatch = (props.event === 'Tornado Watch' || props.event === 'Severe Thunderstorm Watch'), watchNumber = null;
            if (isWatch && props.parameters && props.parameters.VTEC && props.parameters.VTEC[0]) { const vtecParts = props.parameters.VTEC[0].split('.'); if (vtecParts.length >= 6) watchNumber = vtecParts[5]; }
            document.getElementById('full-alert-text-content').innerHTML = `<h4>${props.specificEventName || props.event}</h4><p><strong>Sent:</strong> ${new Date(props.sent).toLocaleString()}</p><p><strong>Expires:</strong> ${new Date(props.expires).toLocaleString()}</p><p><strong>Affected:</strong> ${props.areaDesc}</p><p>&nbsp;</p><p><strong>Description:</strong></p><div id="alert-description-container"><p>${watchNumber ? 'Loading...' : formattedD}</p></div>${props.instruction ? `<p>&nbsp;</p><p><strong>Instructions:</strong></p><p>${formattedI}</p>` : ''}`;
            overlay.style.display = 'flex'; 
            if (watchNumber) {
                try {
                    Logger.debug('showFullAlertTextPopup', 'Extracting SPC text replacement for watch', { watchNumber });
                    const url = `https://www.spc.noaa.gov/products/watch/ww${watchNumber}.html`, res = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`), html = await res.text();
                    const pre = new DOMParser().parseFromString(html, 'text/html').querySelector('pre'), spcText = pre ? pre.textContent : null;
                    if (spcText) document.getElementById('alert-description-container').innerHTML = `<p>${formatNwsText(spcText)}</p>`; else document.getElementById('alert-description-container').innerHTML = `<p>${formattedD}</p>`;
                } catch (e) { Logger.error('showFullAlertTextPopup.watchParse', e); document.getElementById('alert-description-container').innerHTML = `<p>${formattedD}</p>`; }
            }
        }

        async function showFullSpcTextPopup(item) {
            Logger.debug('showFullSpcTextPopup', 'Displaying full textual SPC analysis block', { day: activeSpcDay });
            const overlay = document.getElementById('full-alert-text-popup-overlay'), el = document.getElementById('full-alert-text-popup'), rgba = hexToRgba(item.properties.fill || '#FFFFFF', 0.5);
            el.style.borderLeft = el.style.borderTop = el.style.borderRight = `5px solid ${rgba}`;
            document.getElementById('full-alert-text-content').innerHTML = `<h4>SPC Day ${activeSpcDay} Discussion</h4><p>Loading...</p>`;
            overlay.style.display = 'flex'; 
            const text = await fetchSpcOutlookText(activeSpcDay);
            document.getElementById('full-alert-text-content').innerHTML = `<h4>SPC Day ${activeSpcDay} Discussion</h4><p>${formatNwsText(text)}</p>`;
        }

        function handleOutlookShortcut(day) {
            Logger.debug('handleOutlookShortcut', 'Responding to keyboard bind for outlook changes', { key: day });
            const types = outlookTypes[day]; if (!types) return;
            let next = (activeSpcDay === day) ? types[(types.indexOf(activeSpcType) + 1) % types.length] : types[0];
            activeSpcDay = day; activeSpcType = next; 
            Logger.info('Setting changed: SPC Outlook', { day: activeSpcDay, type: activeSpcType });
            updateSpcLayerVisibility(); if (window.saveCurrentState) window.saveCurrentState();
            showToast(`Outlook: Day ${day} ${typeLabels[next]}`);
        }

        map.on('load', async () => {
            Logger.info('MapLibre GL map base successfully loaded');
            Logger.debug('map.on(load)', 'Initializing map load sequence tasks');
            
            await setupMapData(); 
            updateSpcLayerVisibility(); 
            updateSpcOutlooks(); 
            geocodeAndPlaceMarker(); 
            checkRadarStatus();
            
            let willFlyToRadar = false;

            if (urlRadarRequest) {
                const reqId = urlRadarRequest.id.toLowerCase();
                const site = allRadarSitesData.find(s => s.properties.id.toLowerCase() === reqId);
                if (site) {
                    const stType = site.properties.stationType;
                    if (urlRadarRequest.type === 'r') activeRadarProductCode = (stType === 'TDWR' ? 'bref1' : 'sr_bref');
                    else if (urlRadarRequest.type === 'v') activeRadarProductCode = (stType === 'TDWR' ? 'bvel' : 'sr_bvel');
                    else if (urlRadarRequest.type === 'l') activeRadarProductCode = (stType === 'TDWR' ? 'brefl' : 'sr_bref');
                    activeSiteIdForData = reqId;
                    Logger.info('URL radar parameter evaluated and successfully applied', { site: reqId, product: activeRadarProductCode });
                } else {
                    Logger.error('URL radar param', new Error('Radar site not found in database'), { requestedId: reqId });
                }
            }

            if (activeSiteIdForData && activeRadarProductCode) { 
                const s = activeSiteIdForData, p = activeRadarProductCode; 
                activeSiteIdForData = activeRadarProductCode = null; 
                toggleRadarProduct(s, p); 
                
                if (flyToRadarSetting) {
                    const site = allRadarSitesData.find(site => site.properties.id.toLowerCase() === s);
                    if (site) {
                        willFlyToRadar = true;
                        Logger.debug('map.on(load)', 'Flying to initialized radar site', { radarId: s });
                        map.flyTo({ center: site.geometry.coordinates, zoom: 7, essential: true });
                    }
                }
            }

            if (!willFlyToRadar && saveSettingsEnabled) {
                const savedZoom = localStorage.getItem('lastZoom');
                const savedCenter = localStorage.getItem('lastCenter');
                if (savedZoom && savedCenter) {
                    try {
                        const parsedCenter = JSON.parse(savedCenter);
                        Logger.info('Setting restored: Map Zoom & Center via flyTo');
                        Logger.debug('map.on(load)', 'Flying to previously saved location', { center: parsedCenter, zoom: savedZoom });
                        map.flyTo({ center: parsedCenter, zoom: parseFloat(savedZoom), essential: true });
                    } catch (e) {
                        Logger.error('map.on(load).parseCenter', e);
                    }
                }
            }
            
            setInterval(checkRadarStatus, 480000); setInterval(updateSpcOutlooks, 480000);
            await Promise.all([updatePolygonAlerts(true), updateZoneAlerts(true)]);
            isInitialLoad = false;
            setInterval(updatePolygonAlerts, 60000); 
            setInterval(updateZoneAlerts, 150000);
            setInterval(updateRadar, 90000); 
            setInterval(updateSingleSiteRadar, 60000);
            
            map.on('moveend', () => {
                if (saveSettingsEnabled) {
                    localStorage.setItem('lastZoom', map.getZoom());
                    localStorage.setItem('lastCenter', JSON.stringify(map.getCenter()));
                    Logger.debug('map.moveend', 'Saved current zoom and center', { zoom: map.getZoom(), center: map.getCenter() });
                }
            });

            map.on('contextmenu', (e) => {
                Logger.debug('map.contextmenu', 'Map right click interpreted for nearest radar site search');
                e.preventDefault(); closeAllPopups(); let nearest = null, min = Infinity;
                allRadarSitesData.forEach(s => {
                    const props = s.properties; if (props.isOffline) return;
                    if (radarSiteSelectionMode === 'Both' || radarSiteSelectionMode === props.stationType) {
                        const dist = e.lngLat.distanceTo(new maplibregl.LngLat(s.geometry.coordinates[0], s.geometry.coordinates[1]));
                        if (dist < min) { min = dist; nearest = s; }
                    }
                });
                if (nearest) {
                    const id = nearest.properties.id.toLowerCase(), type = nearest.properties.stationType;
                    Logger.debug('map.contextmenu', 'Radar site found nearby', { radarId: id });
                    let prod;
                    if (activeRadarProductCode) {
                        if (activeRadarProductCode.includes('vel')) prod = (type === 'TDWR' ? 'bvel' : 'sr_bvel');
                        else if (activeRadarProductCode === 'brefl') prod = (type === 'TDWR' ? 'brefl' : 'sr_bref');
                        else prod = (type === 'TDWR' ? 'bref1' : 'sr_bref');
                    } else prod = (type === 'TDWR' ? 'bref1' : 'sr_bref');
                    if (flyToRadarSetting) { 
                        Logger.debug('map.contextmenu', 'Flying to nearest radar site', { radarId: id, coordinates: nearest.geometry.coordinates });
                        map.flyTo({ center: nearest.geometry.coordinates, zoom: 7, essential: true }); 
                        if (activeSiteIdForData !== id) toggleRadarProduct(id, prod); 
                    } else toggleRadarProduct(id, prod);
                } else {
                    Logger.debug('map.contextmenu', 'No valid radar sites isolated in boundary');
                }
            });
        });

        map.on('click', (e) => {
            Logger.debug('map.click', 'Map canvas selected, analyzing intersecting features', { coords: e.lngLat });
            if (currentMapPopup) { closeAllPopups(); return; }
            const features = map.queryRenderedFeatures(e.point, { layers: [layerIds.radarSites, layerIds.alertsZone, layerIds.alertsPolygon, ...allSpcLayerIds] });
            closeAllPopups(); if (!features.length) return; const top = features[0];
            if (top.layer.id === layerIds.radarSites) {
                const site = allRadarSitesData.find(s => s.properties.id === top.properties.id);
                if (site && !site.properties.isOffline) {
                    const id = site.properties.id.toLowerCase(), type = site.properties.stationType;
                    Logger.debug('map.click', 'Site point chosen', { radarId: id });
                    if (activeSiteIdForData === id) { removeSingleSiteLayer(); activeRadarProductCode = activeSiteIdForData = null; map.setPaintProperty(layerIds.radarSites, 'circle-color', radarSiteDefaultColor); updateMosaicVisibility(); if (window.saveCurrentState) window.saveCurrentState(); return; }
                    let prod;
                    if (activeRadarProductCode) {
                        if (activeRadarProductCode.includes('vel')) prod = (type === 'TDWR' ? 'bvel' : 'sr_bvel');
                        else if (activeRadarProductCode === 'brefl') prod = (type === 'TDWR' ? 'brefl' : 'sr_bref');
                        else prod = (type === 'TDWR' ? 'bref1' : 'sr_bref');
                    } else prod = (type === 'TDWR' ? 'bref1' : 'sr_bref');
                    toggleRadarProduct(id, prod);
                }
            } else {
                const alerts = map.queryRenderedFeatures(e.point, { layers: [layerIds.alertsZone, layerIds.alertsPolygon] }).map(f => { const found = [...globalPolyAlerts, ...globalZoneAlerts].find(a => a.properties.id === f.properties.id); return found ? { type: 'alert', feature: found, properties: found.properties } : null; }).filter(Boolean);
                const spc = activeSpcDay !== 'none' ? map.queryRenderedFeatures(e.point, { layers: allSpcLayerIds }).map(f => ({ type: 'outlook', properties: f.properties })) : [];
                const items = [...new Map(alerts.concat(spc).map(i => [i.properties.id || i.properties.LABEL, i])).values()];
                Logger.debug('map.click', 'Multiple geometries identified inside click bounds', { itemsLength: items.length });
                if (items.length) showAlertMapPopup(items, e.lngLat);
            }
        });

        const ptr = () => { map.getCanvas().style.cursor = 'pointer'; }; 
        const def = () => { map.getCanvas().style.cursor = ''; };
        [layerIds.alertsZone, layerIds.alertsPolygon, layerIds.radarSites, ...allSpcLayerIds].forEach(l => { 
            map.on('mouseenter', l, () => { Logger.debug('map.mouseenter', 'Layer hovered', { layer: l }); ptr(); }); 
            map.on('mouseleave', l, () => { Logger.debug('map.mouseleave', 'Layer hover exited', { layer: l }); def(); }); 
        });

        document.addEventListener('keydown', (e) => {
            if (!e.shiftKey) return;
            Logger.debug('document.keydown', 'Shift key combo triggered', { code: e.code });
            if (e.code === 'KeyU') {
                if (debugModeEnabled) {
                    Logger.info('Shift+U pressed, opening debug file filepicker');
                    document.getElementById('debug-file-input').click();
                    showToast("Upload Debug File");
                }
                return;
            }
            if (e.code === 'KeyA') { toggleAllAlerts(); return; }
            if (e.code === 'KeyF') {
                Logger.debug('document.keydown', 'Flying to default center', { coordinates: [-97, 39] });
                map.flyTo({ center: [-97, 39], zoom: 3, essential: true });
                removeSingleSiteLayer();
                activeRadarProductCode = null; activeSiteIdForData = null; activeSpcDay = 'none'; activeSpcType = 'none'; alertsEnabled = true; zoneAlertsEnabled = true;
                const rTog = document.getElementById('radar-toggle'), sTog = document.getElementById('radar-sites-toggle'), zUI = document.getElementById('zone-alerts-settings-toggle-ui');
                rTog.checked = true; sTog.checked = true; zUI.classList.add('active');
                updateSpcLayerVisibility(); updateMosaicVisibility();
                if (map.getLayer(layerIds.radarSites)) map.setLayoutProperty(layerIds.radarSites, 'visibility', 'visible');
                map.setPaintProperty(layerIds.radarSites, 'circle-color', radarSiteDefaultColor);
                [layerIds.alertsZone, layerIds.alertsZoneBorder, layerIds.alertsPolygon, layerIds.alertsPolygonBorder].forEach(l => { if (map.getLayer(l)) map.setLayoutProperty(l, 'visibility', 'visible'); });
                Promise.all([updatePolygonAlerts(true), updateZoneAlerts(true)]);
                showToast("View & Layers Reset"); return;
            }
            const keys = { 'KeyM': ['sidebar-mosaic-btn', 'radar-toggle', 'Mosaic'], 'KeyS': ['sidebar-sites-btn', 'radar-sites-toggle', 'Sites'] };
            if (keys[e.code]) { document.getElementById(keys[e.code][0]).click(); const chk = document.getElementById(keys[e.code][1]); showToast(`${keys[e.code][2]}: ${chk.checked ? 'On' : 'Off'}`); }
            else if (e.code === 'KeyZ') { 
                zoneAlertsEnabled = !zoneAlertsEnabled;
                document.getElementById('zone-alerts-settings-toggle-ui').classList.toggle('active');
                Logger.info('Setting changed: Zone Alerts', { enabled: zoneAlertsEnabled });
                if (zoneAlertsEnabled && alertsEnabled) { showToast("Zone Alerts: On"); updateZoneAlerts(true); } else if (!zoneAlertsEnabled) { showToast("Zone Alerts: Off"); if (map.getSource('alerts-zone')) map.getSource('alerts-zone').setData({ type: 'FeatureCollection', features: [] }); globalZoneAlerts = []; }
            }
            else if (e.code === 'Backquote') { activeSpcDay = activeSpcType = 'none'; Logger.info('Setting changed: SPC Outlook', { day: 'none', type: 'none' }); updateSpcLayerVisibility(); if (window.saveCurrentState) window.saveCurrentState(); showToast('Outlook: Off'); }
            else if (e.code.startsWith('Digit')) handleOutlookShortcut(e.code.slice(5));
            if (activeSiteIdForData) {
                const s = allRadarSitesData.find(site => site.properties.id.toLowerCase() === activeSiteIdForData);
                let p = (e.code === 'KeyR') ? (s.properties.stationType === 'TDWR' ? 'bref1' : 'sr_bref') : (e.code === 'KeyV') ? (s.properties.stationType === 'TDWR' ? 'bvel' : 'sr_bvel') : (e.code === 'KeyL' && s.properties.stationType === 'TDWR') ? 'brefl' : null;
                if (p && p !== activeRadarProductCode) toggleRadarProduct(activeSiteIdForData, p);
            }
        });
    </script>
</body>
</html>
